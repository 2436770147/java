什么是JVM
JVM是java虚拟机，编译好的字节码文件通过ClassLoader类加载器转换成机器能识别的语言，一次编译到处执行，
跨平台性强

简述一下JVM加载Class文件原理
通过ClassLoader类加载器加载，有3种类加载器，他们之间有父子关系，加载类的请求会依次询问父加载器是否加载过，
即双亲委派机制

GC过程
new对象存放在新生代中，当新生代中Eden区满了会触发GC，把有引用的对象复制到from区然后Eden区回收垃圾，
当Eden区再次GC时，会将Eden区和from区有引用的对象复制到to区，Eden区和from区回收垃圾同时对象年龄+1，
然后from区和to区会交换身份，当对象年龄达到老年标准，对象就会被复制到老年代，俗称young GC；
但老年代满了会触发old GC，young GC和old GC会产生STW，会停止除GC任务外的一切任务

常见的垃圾回收算法有哪些？
引用计数（JVM已废除）、复制（用于新生代）、标记清除和标记整理（用于老年代）

什么是GC Roots？
GC Roots是枚举根节点，可达性分析的对象起点，从这个起点开始，能被遍历到的对象表示可达，判定为存活，否则
判定死亡

排查故障的方式有哪些？
查看Linux日志；
使用Idea终端jps命令定位进程号，和jstack命令查看java堆栈信息

JVM的XX参数
PrintGCDetails（布尔型）：是否打印GC收集细节；
MatespaceSize（键值型）：设置元空间大小；
MaxTenuringThreshold（键值型）：设置新生代到老年代的年龄条件
通过Idea终端jps命令和jinfo命令查看参数值

查看全局参数命令
查看初始参数：java -XX:+PrintFlagsInitial
查看最终参数：java -XX:+PrintFlagsFinal
=表示没改过
:=表示人为改过或JVM改过

什么是JMM？
JMM是java内存模型，它并不真实存在，是线程级别的工作内存，用于对变量的操作

什么是JUC？
JUC是java并发工具包，它存在于jdk的rj.jar中，它包含atomic包和locks包，
atomic包提供了具有原子型操作的类，通过CAS机制实现，
locks包提供了一些锁的实现，底层是AQS抽象队列同步器

什么是AQS
AQS是抽象队列同步器，是JUC下锁相关的类，将没有获取锁的线程设置成一个int类型的节点状态放到队列里，
当一个线程释放锁后，会将这个队列里的线程唤醒再次尝试获取锁，用getState()获取节点状态，
然后它用了CAS的方法和setState()去更改节点状态

volatile关键字的特性
多线程中，保证数据可见性和禁止指令重排，不保证原子性

什么是AtomicInteger？
AtomicInteger是atomic包下的一个原子包装类，所以它具有原子性，
然后类里面用了volatile修饰value，所以它本身也具有可见性

什么是CAS？
CAS指compareAndSet比较并交换，是底层unsafe类的方法，这个类充当java和操作系统底层
的一个桥梁，可以根据内存地址偏移量判断内存某个位置的值是否是预期值再做修改操作，这也就
保证了数据的原子性

为什么用CAS而不用synchronized？
因为synchronized虽然保证了数据的原子性，但是它性能低于CAS，CAS不用上锁，通过循环判断
（自旋）来保证数据原子性，因为是自旋，避免了频繁的唤醒线程和避免阻塞，所以提高了性能，
但循环时间长了会增加CPU消耗

CAS缺点
循环时间长的话CPU开销大、只能保证一个数据的原子性

什么是ABA问题？
在CAS机制中，如果一个线程比另一个线程结束的要快，那么这个更快结束的线程可以把数据改一次
之后又改回来，这个时候另一个线程才开始要修改数据，此时数据本质上是没有变的，但其实它已经
被别的线程更改过了，所以当前线程也能完成更改，这就是ABA问题

怎么解决ABA问题？
可以用AtomicStampedReference带时间戳（版本号）的原子性对象引用类

集合线程安全问题
List、Set、Map都是线程不安全的，因为它们的add()、put()都没有synchronizeed
解决线程不安全的办法有：
1、List集合可以用Vector、Set集合可以用HashTable、Map集合可以用ConcurrentHashMap
2、可以用Collections集合类下带synchronized同步的List、Set和Map
3、可以用写时复制方法

什么是写时复制？
往list集合添加数据时，先把list复制到一个长度+1的list，最后把要添加的数据加到这个list最后

都知道HashSet的底层是HashMap，为什么HashSet用的是add()而不是put？
其实底层还是用的HashMap的put()，但这里只关心key，至于value用的是Object常量

CountDownLatch、CyclicBarrier、Semaphore有什么区别？
CountDownLatch用于主线程等待所有子线程执行完成再执行，递减统计；
CyclicBarrier用于在每个线程执行完之后阻塞，当最后一个线程执行完之后再一起执行，递增统计；
Semaphore用于1、共享资源的互斥、2、并发量的控制

什么是BlockingQueue？
BlockingQueue是阻塞队列，常用的有ArrayBlockingQueue数组有界阻塞队列、
LinkedBlockingQueue链表理论有界阻塞队列（默认Integer类的最大值），也可以指定大小、
SynchronousQueue是一个同步队列，生产者消费者模式

线程池的实现方式有哪些？
常用的线程池有3种，
FixedThreadPool：创建一个指定大小的线程池；
SingleThreadExecutor：创建一个单一线程的线程池；
CachedThreadPool：创建一个自适应扩容的线程池
FixedThreadPool和SingleThreadExecutor的任务队列都是LinkedBlockingQueue，大小默认Integer类的最大值，
而CachedThreadPool虽然用的是SynchronousQueue，但是它的最大同时执行线程数是Integer类的最大值，所以
都容易导致OOM（内存不足），还是建议通过ThreadPoolExecutor手写线程池

ThreadPoolExecutor线程池7大参数
corePoolSize：核心线程数；
maximumPoolSize：最大同时执行线程数；
keepAliveTime：非核心线程存活时间；
unit：时间单位；
workQueue：任务队列，还未执行的任务；
threadFactory：用于创建线程的工厂；
handler：拒绝策略，队列满时且工作线程大于最大同时执行线程数时触发

线程池底层工作原理
首先有核心线程在处理任务，如果并发高起来了，会将后面的任务放到任务队列，当任务队列也满了的时候，
就会开启非核心线程来执行陆续进来的任务，直到工作线程大于最大同时执行线程数时，就会触发拒绝
策略，如果并发降下来了，按照非核心线程存活时间，关闭非核心线程

ThreadPoolExecutor线程池4大拒绝策略
AbortPolicy（默认）：抛出拒绝执行异常，且停止执行；
CallerRunsPolicy：调用者执行机制，把任务交给父线程执行；
DiscardOldestPolicy：抛弃队列中等待最久的任务并将当前任务加入队列尝试再次提交；
DiscardPolicy：丢弃任务，不处理也不抛异常

