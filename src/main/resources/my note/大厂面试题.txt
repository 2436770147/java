什么是JVM
JVM是java虚拟机，编译好的字节码文件通过ClassLoader转换成机器能识别的语言，所以JVM
是具有跨平台特性的

简述一下JVM加载Class文件原理
通过ClassLoader类加载器加载，有3种类加载器，他们之间有父子关系，加载类的请求会依次询问父加载器是否加载过，
即双亲委派机制

什么是JMM？
JMM是java内存模型，它并不真实存在，是线程级别的工作内存，用于对变量的操作

什么是JUC？
JUC是java并发工具包，它存在于jdk的rj.jar中，它包含atomic包和locks包，
atomic包提供了具有原子型操作的类，通过CAS机制实现，
locks包提供了一些锁的实现，底层是AQS抽象队列同步器

什么是AQS
AQS是抽象队列同步器，是JUC下锁相关的类，将没有获取锁的线程设置成一个int类型的节点状态放到
队列里，int默认是0，当一个线程释放锁后，会将这个队列里的线程唤醒，用getState()获取节点状态，
然后它用了CAS的方法和setState()去更改节点状态

thread.yield()的作用
线程让步，将当前线程改为可运行状态

volatile关键字的特性
多线程中，保证数据可见性和禁止指令重排，不保证原子性

什么是AtomicInteger？
AtomicInteger是atomic包下的一个原子包装类，所以它具有原子性，
然后类里面用了volatile修饰value，所以它本身也具有可见性

什么是CAS？
CAS指compareAndSet比较并交换，是底层unsafe类的方法，这个类充当java和操作系统底层
的一个桥梁，可以根据内存地址偏移量判断内存某个位置的值是否是预期值再做修改操作，这也就
保证了数据的原子性

为什么用CAS而不用synchronized？
因为synchronized虽然保证了数据的原子性，但是它性能低于CAS，CAS不用上锁，通过循环判断
（自旋）来保证数据原子性，因为是自旋，避免了频繁的唤醒线程和避免阻塞，所以提高了性能，
但循环时间长了会增加CPU消耗

CAS缺点
循环时间长的话CPU开销大、只能保证一个数据的原子性

什么是ABA问题？
在CAS机制中，如果一个线程比另一个线程结束的要快，那么这个更快结束的线程可以把数据改一次
之后又改回来，这个时候另一个线程才开始要修改数据，此时数据本质上是没有变的，但其实它已经
被别的线程更改过了，所以当前线程也能完成更改，这就是ABA问题

怎么解决ABA问题？
可以用AtomicStampedReference带时间戳（版本号）的原子性对象引用类

集合线程安全问题
List、Set、Map都是线程不安全的，因为它们的add()、put()都没有synchronizeed
解决线程不安全的办法有：
1、List集合可以用Vector、Set集合可以用HashTable、Map集合可以用ConcurrentHashMap
2、可以用Collections集合类下带synchronized同步的List、Set和Map
3、可以用写时复制方法

什么是写时复制？
往list集合添加数据时，先把list复制到一个长度+1的list，最后把要添加的数据加到这个list最后

都知道HashSet的底层是HashMap，为什么HashSet用的是add()而不是put？
其实底层还是用的HashMap的put()，但这里只关心key，至于value用的是Object常量

CountDownLatch、CyclicBarrier、Semaphore有什么区别？
CountDownLatch用于主线程等待所有子线程执行完成再执行，递减统计；
CyclicBarrier用于在每个线程执行完之后阻塞，当最后一个线程执行完之后再一起执行，递增统计；
Semaphore用于1、共享资源的互斥、2、并发量的控制

什么是BlockingQueue？
BlockingQueue是阻塞队列，常用的有ArrayBlockingQueue数组有界阻塞队列、
LinkedBlockingQueue链表理论有界阻塞队列（默认Integer类的最大值）、
SynchronousQueue是一个同步队列，生产者消费者模式

ThreadPoolExecutor线程池7大参数
corePoolSize：核心线程数；
maximumPoolSize：最大同时执行线程数；
keepAliveTime：非核心线程存活时间；
unit：时间单位；
workQueue：任务队列，还未执行的任务；
threadFactory：用于创建线程的工厂；
handler：拒绝策略，队列满时且工作线程大于等于最大同时执行线程数时触发

线程池底层工作原理
首先有核心线程在处理任务，如果并发高起来了，会将这些任务放到任务队列，当任务队列也满了的时候，
就会开启非核心线程来执行陆续进来的任务，直到工作线程大于等于最大同时执行线程时，就会触发拒绝
策略，如果并发降下来了，按照非核心线程存活时间，关闭非核心线程

